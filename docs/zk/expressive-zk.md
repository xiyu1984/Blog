f# Expressive zk

This article aims to make an easy and concrete expression to help understand the main principle of the ZKP technology underground.  

Discussions here are more about the theoretical pieces of knowledges including both `SNARK` and `STARK`, based on implementations including [starknet](https://medium.com/starkware/a-framework-for-efficient-starks-19608ba06fbe), [plonky2](https://github.com/0xPolygonZero/plonky2), and [halo2](git@github.com:zcash/halo2.git).  

Note that this is just a personal comprehension of the knowledge context of the Zero Knowledge Proofs from the technical view.  

## Framework

`ZKP` is proof, not calculation. The highly generalized framework of `SNARK`s and `STARK`s can be both described as follows:   

- Arithmetization: translates a computation into a polynomial
- Polynomial commitment scheme: determines how to generate a proof from the polynomial to prove the computation is right, and how to verify it based on the polynomial

## Arithmetization

`Arithmetization`, more completely, `Arithmetization and Arithmetic Constraint System`, generates a polynomial from a computation.  

A computation can be broken down into:

- a *execution trace*: a series of intermidiate values generated by the calculation process, along with the start(*inputs*) to the end(*outputs*)
- *Arithmetic Constraint*: 
    - *boundary constraints*: normally and simplified, *inputs* and *outputs*
    - *transition constraints*: intuitively, the calculation process itself, which establishes some constraints between the consecutive states of in the *execution trace*

[plonky2](https://github.com/0xPolygonZero/plonky2) and [halo2](git@github.com:zcash/halo2.git) uses `PLONKish` arithmetization derived from [PLONK](https://eprint.iacr.org/2019/953). For beginners, a simplier and more intuitive introduction can be found at the articles by `starknet`, [Arithmetization I](https://medium.com/starkware/arithmetization-i-15c046390862) and [Arithmetization II](https://medium.com/starkware/arithmetization-ii-403c3b3f4355).  


`Arithmetization` generates a polynomial, for example, a polynomial with degree `d`:  

$$f(x)=\sum^{d}_{i=0}\alpha^{i}x^{i}$$  

Our purpose is to use $f(x)$ to prove the original computation is right. In my opinion, the key point to understand why and how $f(x)$ can prove is finding out the practical significance of it.  

- unvariable parts
- variable parts
- In the simplified situation mentioned in [Arithmetization I](https://medium.com/starkware/arithmetization-i-15c046390862) and [Arithmetization II](https://medium.com/starkware/arithmetization-ii-403c3b3f4355), $f(x)$ satisfies the *arithmetic constraints* means it is evaluated to be `0`s at the points in the *execution trace*. Similiar but more complex things happen in `PLONKish Arithmetizations`. 
- That is, if $f(x)$ is evaluated to be `0`s at suitable points, all the `Arithmetic Constraint` will be satisfied, then the computation will be right with the *inputs* and *outputs*.   

## Polynomial commitment scheme
